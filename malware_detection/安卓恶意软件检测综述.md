## 安卓恶意软件检测
###  Android系统安全机制
#### 1. 应用程序签名机制
应用程序签名机制指的是在应用程序发布时，由开发者采用私钥进行签名，在安装程序时，Android系统使用公钥对应用程序进行验证溯源，从而与开发者间建立信任关系。通过数字签名，系统一方面可以实现对程序的版本控制，另一方面也可以对应用程序安装包的完整性进行验证，同时可以有效检测重打包攻击、应用篡改等恶意行为，从而过滤恶意应用。但攻击者有时也会伪造第三方应用签名，逃过系统检测。签名机制按照签名对象可以分为两类：对程序安装包解压后的非目录和非过滤文件进行签名验证，以及对压缩安装包整体进行签名验证。
#### 2. 权限机制
权限机制指的是应用程序在安装时和运行过程中，向系统申请所需服务的权限，并根据获取的权限运行相应服务，其定义信息包括包名、标签、描述和保护级别等.
#### 3. 进程沙箱隔离机制
进程沙箱隔离机制指的是应用程序始终运行于系统为其开辟的独立Dalvik虚拟机中，拥有独立的运行空间和系统资源空间，从而保证应用程序间的独立，限制不可信程序的权限。具体来说，每个应用程序在安装时都被系统赋予了唯一的UID，在程序运行期间，系统隔离非同一UID的应用程序及资源，使其互不干扰，进而使各个应用程序的资源都得到安全保护。
### 常见的恶意软件攻击方法
#### 1. 重打包攻击
重打包攻击指的是攻击者对原始应用程序进行反编译，将恶意代码植入应用程序中，然后通过伪造应用签名通过系统检测，重新打包为第三方应用进行发布。
#### 2. 提权攻击
提权攻击是指攻击者利用Android系统漏洞或第三方代理软件等，提升普通应用程序的系统服务权限，从而获得其所需权限。一旦恶意应用拥有较高的系统权限，就会对系统造成巨大的安全威胁。
#### 3. 其他攻击
随着Android系统的更新与发展，市场上出现了许多其他的恶意软件攻击方法。比如利用剪切板功能简单且无需申请额外权限的特点，恶意篡改剪切板内容，危害系统安全；植入抓取代码，窃取用户隐私信息，进行电子诈骗；利用调试接口传播恶意软件等。
### 恶意软件检测的基本方法
恶意软件检测问题本质上是一个分类问题，对给定的应用程序，判断其为恶意软件还是正常软件。根据解决分类问题的一般性方法，恶意软件检测的大致流程如图所示。
![image](https://github.com/Cyber-Security-Team/binary_function_similarity/blob/main/malware_detection/image/1.jpg)
首先获取谷歌应用市场和第三方应用市场中的正常软件程序包，以及恶意软件程序包，构成数据集；然后从中抽取特征信息，并进行特征预处理；最后根据特征值信息，基于规则或分类算法完成分类任务。
Android应用程序安装包是一个后缀为.apk的压缩文件，解压后可得如下文件：
![image](https://github.com/Cyber-Security-Team/binary_function_similarity/blob/main/malware_detection/image/2.jpg)  
常见的恶意软件检测方法，主要是基于AndroidManifest.xml文件和classes.dex文件进行特征抽取。  
AndroidManifest.xml文件是Android应用程序的全局配置文件，提供了在程序运行前系统所需的各种必要信息，包括应用的包名、版本号、权限信息、硬件信息等。  
classes.dex文件是应用程序的二进制可执行文件，java代码首先会被编译为.class文件，得到的类文件被翻译成Dalvik字节码，最终合并为一个或多个可执行dex文件[4]。在恶意软件检测方法中，有的研究者会首先对其进行反编译，然后再抽取特征，有的研究者则会直接利用原始字节码序列或对其进行截取、处理。
### Android恶意软件检测方法
#### 静态检测方法
静态检测方法是指在应用程序不运行的情况下，基于应用程序特征进行系统检测分析[6-7]。其常用的特征包括应用权限、Java代码、网络地址、硬件组件等。静态检测方法优点是检测速度快，缺点是无法有效识别利用了静态检测对抗技术（如代码混淆）的恶意应用程序。常见的静态检测方法包括基于应用程序安装包文件特征的检测、基于应用程序代码分析的检测、基于应用布局特征的检测等。
基于应用程序安装包文件特征的检测方法，关注表1所示的签名文件、清单文件、资源文件及代码文件等，从中抽取特征表示，通过相似性比较或模型训练的方法完成恶意应用检测。比如Zhou等[8]提出DroidMoss模型抽取应用的代码特征，采用模糊哈希的方法生成应用程序特定的指纹信息，然后进行相似度比较，从而判断是否为恶意应用程序，但该方法无法有效应对代码混淆等对抗攻击。Nicheporuk等[9]基于API方法调用和权限信息，采用卷积神经网络训练模型完成分类。  

基于应用程序代码分析的检测方法，更加关注代码文件，将应用程序代码抽象为控制流图、API函数图或程序依赖图，然后再进行相似性比较。比如Crussell等[10]提出DNADroid模型基于应用程序依赖图完成相似性计算，有效应对重打包攻击。为了提升对重打包应用的检测效率，同时有效对抗代码混淆攻击，汪润等[11]提出可以进行粗细两个粒度的检测并抽取代码的深层语义信息。该模型首先进行粗粒度检测，将应用程序依赖图抽象为程序语义特征，计算程序语义特征间相似性，实现快速检测；对于细粒度检测，则是将程序依赖图作为特征，实现更为准确的恶意应用检测。
基于应用布局特征的检测方法，关注应用程序的UI界面，从中抽取特征信息作为分类依据。比如Zhang等[12] 提出可以根据应用界面生成界面图，然后计算图间的相似性。该方法检测速度快，但检测精度有限，因此可以将其与代码特征相结合，兼顾检测速度与精度。
#### 动态检测方法
动态检测方法是在沙盒环境中运行程序，并跟踪程序的API调用序列、系统调用、网络流量和CPU数据，以监视程序运行期间的数据流[5]，获取程序运行过程中的动态特征。动态检测方法的关键点在于如何对程序的全部功能进行检测，如何保证测试用例的真实性及全面性。该方法在实际应用中通常需要占用一定的系统资源且检测速度较慢，但对于未知恶意软件的检测通常具有较好的表现。常见的动态检测方法分为两类：基于应用行为分析的检测和基于污点跟踪的检测。 

对应用行为的分析目标，可以选择应用程序对系统服务的调用信息，也可以选择非系统调用信息，如实时交互信息或应用运行信息等。CopperDroid模型，结合系统调用和Binder通信行为数据，重构了恶意应用程序的高级语义信息，最终输出恶意行为，包括系统相关行为和Android相关行为两种。该方法可以有效抵抗代码混淆攻击，且无需修改系统源码，部署方便。PuppetDroid模型，基于用户与应用程序的实时交互行为获取特征信息，进行恶意应用检测，与普通的自动UI方法相比达到了更高的代码覆盖率。  

基于应用行为数据获取的特征表示，忽视了数据间的关联性信息，且无法刻画程序的全流程行为。为解决该问题，提出基于污点跟踪的恶意软件检测方法——TaintDroid。该方法从污染源标记敏感信息，动态追踪数据流和系统调用，实现了变量级、信息级、方法级和文件级的污点跟踪。
#### 混合检测方法
无论是静态检测方法还是动态检测方法，都具有一定的局限性。静态检测无法捕获应用程序在运行时的行为信息，而动态检测无法实现完整的代码覆盖范围。因此，有研究者提出混合检测方法，即静态和动态分析组合的方法，可以使Android恶意软件检测更加准确和高效。在静态检测和动态检测中使用了相同的建模方法，都基于API调用序列构建马尔科夫链，最终比较两种方法的检测性能。结果表明，混合检测的方法具有更好的性能表现。
